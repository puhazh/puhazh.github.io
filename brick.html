<!doctype html>
<html>
<head>
	<meta charset="UTF-8" />
	<title>Bricks</title>
	<style id="css">
	@font-face {
		font-family: 'Digital';
		src: url('fonts/digital-7.ttf');
	}
	</style>
</head>
<body>
<b> Try using the arrow keys!</b>
<br/><br/>
<canvas id="gameConsole" width="550" height="625" style="border:1px solid #c3c3c3;float:left; margin-left:0px;margin-right:20px;margin-bottom:15px"> 
No Support for Canvas, use a modern browser.
</canvas>

<script>
	
	var canvas=document.getElementById("gameConsole");
	var ctx=canvas.getContext("2d");
	var CANVAS_WIDTH = 550;
	var CANVAS_HEIGHT = 625;
	var PLAY_AREA_WIDTH = 350;
	var PLAY_AREA_HEIGHT = 625;
	var BRICK_SIZE = 25;
	
	var score = 0;
	var level = 0;
	var nextPiece = 0;
	var currentPiece = 0;
	var curPieceIndex=0;
	var nextPieceIndex=0;
	var rotationIndex=0
	var board = new Array(26); 
	var SQUARE_PIECE=[0x6600];
	var REG_Z_PIECE=[0x6C00, 0x8C40];
	var INV_Z_PIECE=[0xC600, 0x4C80];
	var I_PIECE=[0x4444, 0xF000];
	var T_PIECE=[0x4E00, 0x4640, 0xE400, 0x2620];
	var pieces=[SQUARE_PIECE, REG_Z_PIECE, INV_Z_PIECE, I_PIECE, T_PIECE];
	
	var SCORE_INCREMENT=10;
	var BONUS_INCREMENT=15;
	
	var boardColor = '#A0A0A0';
	var blocksColor = '#000000';
	var splitLinesColor = '#D0D0D0';
	var blockCurX = 5;
	var blockCurY = 21;
		
	function init(){
		ctx.translate(0, CANVAS_HEIGHT); // Move the origin to bottom left
		initModel();
		paint();
		startNewGame();
		playGame();
		// return setInterval(paint, 2000); // Paint is called each 10ms, to keep the view updated
	}
	
	function paint(){
		clear();
		drawConsole();
	}
	
	function clear(){
		ctx.clearRect(0, 0, CANVAS_WIDTH, -CANVAS_HEIGHT);
	}
	
	function initModel(){
		// Only the LSB 16 bits are used, initialize only that as desired
		board[0]=0xFFFF; // Bottom hidden layer
		for(i = 1; i < board.length; i++){
			board[i]=0x8001; // hidden outer boundary on left and right
		}
		// nextPiece=0x0000;
	}
	
	function drawConsole(){ // Creates the game console with play area, next piece, score, etc
		
		// Draw the play area border
		ctx.lineWidth = 3;
		ctx.strokeStyle = '#000000';
		ctx.beginPath();
		ctx.rect(0, 0, PLAY_AREA_WIDTH, -PLAY_AREA_HEIGHT);
		ctx.fillStyle=boardColor;
		ctx.fill(); 
		ctx.stroke();
		
		ctx.strokeStyle=splitLinesColor;
		ctx.lineWidth = 1;		
		
		// Draw the vertical lines - Play Area
		for(i=1; i<14;i++)
		{
			ctx.beginPath();
			ctx.moveTo(i*BRICK_SIZE, 0);
			ctx.lineTo(i*BRICK_SIZE, -PLAY_AREA_HEIGHT);
			ctx.stroke();
		}
		
		// Draw the horizontal lines - Play Area
		for(i=1;i<25;i++)
		{
			ctx.beginPath();
			ctx.moveTo(0, -i*BRICK_SIZE);
			ctx.lineTo(PLAY_AREA_WIDTH, -i*BRICK_SIZE);
			ctx.stroke();
		}
		
		// Draw the next piece area
		ctx.fillStyle = '#000000';
		ctx.font="Bold Italic 15px Verdana";
		ctx.fillText("Next:",PLAY_AREA_WIDTH+50,-(PLAY_AREA_HEIGHT-45));
		
		ctx.beginPath();
		ctx.strokeStyle = '#000000';
		ctx.fillStyle=boardColor;
		ctx.rect(PLAY_AREA_WIDTH+50,-(PLAY_AREA_HEIGHT-50-BRICK_SIZE*4), BRICK_SIZE*4, -BRICK_SIZE*4);
		ctx.fill(); 
		ctx.stroke();
		
		ctx.strokeStyle=splitLinesColor;
		// Draw the vertical lines - Next Piece
		for(i=1; i<4;i++)
		{
			ctx.beginPath();
			ctx.moveTo(PLAY_AREA_WIDTH+50+i*BRICK_SIZE, -(PLAY_AREA_HEIGHT-50-BRICK_SIZE*4));
			ctx.lineTo(PLAY_AREA_WIDTH+50+i*BRICK_SIZE, -(PLAY_AREA_HEIGHT-50));
			ctx.stroke();
		}
		
		// Draw the vertical lines - Next Piece
		for(i=1; i<4;i++)
		{
			ctx.beginPath();
			ctx.moveTo(PLAY_AREA_WIDTH+50, -(PLAY_AREA_HEIGHT-50-BRICK_SIZE*4+i*BRICK_SIZE));
			ctx.lineTo(PLAY_AREA_WIDTH+50+BRICK_SIZE*4, -(PLAY_AREA_HEIGHT-50-BRICK_SIZE*4+i*BRICK_SIZE));
			ctx.stroke();
		}
		
		// Score
		ctx.fillStyle = '#000000';
		ctx.font="Bold Italic 18px Ariel";
		ctx.fillText("Score:",PLAY_AREA_WIDTH+50,-(PLAY_AREA_HEIGHT-BRICK_SIZE*9));
		// ctx.font="20px Digital";
		ctx.fillText(score,PLAY_AREA_WIDTH+50+55,-(PLAY_AREA_HEIGHT-BRICK_SIZE*9));
		
		// Level
		ctx.fillStyle = '#000000';
		ctx.font="Bold Italic 18px Ariel";
		ctx.fillText("Level:",PLAY_AREA_WIDTH+50,-(PLAY_AREA_HEIGHT-BRICK_SIZE*11));
		// ctx.font="18px Digital";
		ctx.fillText(level,PLAY_AREA_WIDTH+50+55,-(PLAY_AREA_HEIGHT-BRICK_SIZE*11));
	}
	
	function updateConsole(blockColor){ // Updates the game console with the model data (game progress, score, level)
				
		// Read each bit and plot the board with the current status
		for(i=1;i<board.length;i++){ // skipped 0, as its bottom hidden
			var bitMask=0x4000; // skip hidden first left
			for(j=1;j<15;j++){
				var bitSet = bitMask & board[i];
				bitMask = bitMask>>1;
				
				if(bitSet!=0){ // The bit is set, set the brick to on in the board
					ctx.fillStyle=blockColor;
					ctx.strokeStyle=splitLinesColor;
					ctx.lineWidth=1;
					ctx.beginPath();
					ctx.rect((j-1)*BRICK_SIZE, -(i-1)*BRICK_SIZE, BRICK_SIZE, -BRICK_SIZE);
					ctx.fill(); 
					ctx.stroke();
				}
			}
		}
		
		drawNextBlock(blocksColor); // Draw the next block data
		
		// Clear the score and level area
		ctx.fillStyle='#FFFFFF';
		ctx.beginPath();
		ctx.rect(PLAY_AREA_WIDTH+50+55,-(PLAY_AREA_HEIGHT-BRICK_SIZE*8),200,200);
		ctx.fill(); 
		
		// Update the score
		ctx.fillStyle = '#000000';
		ctx.font="Bold Italic 18px Ariel";
		ctx.fillText(score,PLAY_AREA_WIDTH+50+55,-(PLAY_AREA_HEIGHT-BRICK_SIZE*9));
		
		// Update the level
		ctx.fillText(level,PLAY_AREA_WIDTH+50+55,-(PLAY_AREA_HEIGHT-BRICK_SIZE*11));
	}
	
	function drawNextBlock(blockColor){ // Color used to clear existing/draw new block
			// Update the next piece with model data
		var bitMask=0x8000;
		var y=0;
		for(i=0;i<16;i++){
			var bitSet = bitMask & nextPiece;
			if(bitSet!=0){ // Check for the set bit in the next piece and set the respective brick
				ctx.fillStyle=blockColor;
				ctx.strokeStyle=splitLinesColor;
				ctx.lineWidth=1;
				ctx.beginPath();
				ctx.rect(PLAY_AREA_WIDTH+50+(i%4)*BRICK_SIZE, -(PLAY_AREA_HEIGHT-50-BRICK_SIZE*4)-y*BRICK_SIZE, BRICK_SIZE, -BRICK_SIZE);
				ctx.fill(); 
				ctx.stroke();
			}
			if(i%4==3) // Increment the column
				y++;
			bitMask = bitMask>>1;
		}
	}
	
	function drawBlock(block, colX, colY, blockColor){ // Displays the block on the board, also used to reset display (when board color is passed)
		var bitMask=0x8000;
		
		for(i=0;i<16;i++){
			var bitSet = bitMask & block;
			if(bitSet!=0){ // Check for the set bit in the current piece and set the respective brick
				ctx.fillStyle=blockColor;
				ctx.strokeStyle=splitLinesColor;
				ctx.lineWidth=1;
				ctx.beginPath();
				ctx.rect(colX*BRICK_SIZE, -colY*BRICK_SIZE, BRICK_SIZE, -BRICK_SIZE);
				ctx.fill(); 
				ctx.stroke();
			}
			colX++;
			if(i%4==3) {// Increment the column
				colY++;
				colX=colX-4;
			}
			bitMask = bitMask>>1;
		}
	
		return;
	}
	
	// Animated row erase effect
	function eraseAnimation(rowNum){
		for(j=1;j<15;j++){
			ctx.fillStyle=boardColor;
			ctx.strokeStyle=splitLinesColor;
			ctx.lineWidth=1;
			ctx.beginPath();
			ctx.rect((j-1)*BRICK_SIZE, -(rowNum-1)*BRICK_SIZE, BRICK_SIZE, -BRICK_SIZE);
			ctx.fill(); 
			ctx.stroke();
		}
	}
	
	function startNewGame(){
		// Start the game
		// Initialize current and next piece
		curPieceIndex=Math.floor(Math.random()*11)%pieces.length;
		nextPieceIndex=Math.floor(Math.random()*11)%pieces.length;
		currentPiece=pieces[curPieceIndex][rotationIndex];
		nextPiece=pieces[nextPieceIndex][rotationIndex];
		
		// Set the scores and level to 0s
		score = 0;
		level = 0;
		
		updateConsole(blocksColor);
		
		// setInterval(playGame, 2000);
	}
	
	function playGame(){

		// Erase the previous block
		
		// Draw the block at current x and y
		drawBlock(currentPiece, blockCurX, blockCurY, '#000000');
		
	}
	
	function canMoveDown(){
	
		// Check if the next row below is filled (any bits set, for both bottom and blocks check)
		var maskPosition = blockCurX+1; // Choose the mask based on the current block position
		
		if( (board[blockCurY]&(0XF000>>maskPosition))<<maskPosition & (currentPiece&0xF000) || 
			(board[blockCurY+1]&(0XF000>>maskPosition))<<maskPosition & ((currentPiece&0x0F00)<<4) || 
			(board[blockCurY+2]&(0XF000>>maskPosition))<<maskPosition & ((currentPiece&0x00F0)<<8) || 
			(board[blockCurY+3]&(0XF000>>maskPosition))<<maskPosition & ((currentPiece&0x000F)<<12) ){
			return false;
		}
		return true;
	}
	
	function canMoveRight(){
		return true;
	}
	
	function canMoveLeft(){
		return true;
	}
		
	function reachedBottom(){
		// The block has reached the least bottom possible
		
		var maskPosition = blockCurX+1; // Choose the mask based on the current block position
		
		// Merge the block to the board
		board[blockCurY+1] = board[blockCurY+1] | (currentPiece&0xF000)>>maskPosition;
		board[blockCurY+2] = board[blockCurY+2] | ((currentPiece&0x0F00)<<4)>>maskPosition;
		board[blockCurY+3] = board[blockCurY+3] | ((currentPiece&0x00F0)<<8)>>maskPosition;
		board[blockCurY+4] = board[blockCurY+4] | ((currentPiece&0x000F)<<12)>>maskPosition;
	
		curPieceIndex=nextPieceIndex;
		currentPiece=nextPiece;
		rotationIndex=0;
	
		drawNextBlock(boardColor); // Erase the next block area
		
		nextPieceIndex=Math.floor(Math.random()*11)%pieces.length;
		nextPiece=pieces[nextPieceIndex][rotationIndex];
		
		updateConsole(boardColor); // Erase board with current values
		
		var bonusEligible = false;
		for(i=1;i<=4;i++){
			if(board[blockCurY+i]==0xFFFF) {
				
				// Increase the score
				if(bonusEligible==true)
					score = score + BONUS_INCREMENT;
				else
					score = score + SCORE_INCREMENT;
				bonusEligible = true;
				
				// Erase the line
				for(j=blockCurY;j<board.length-3;j++){
					// Move all rows above the erased one to one down
					board[j+1]=board[j+2];
				}
				board[board.length-1]= 0x8001;
			}
		}

		blockCurX = 5;
		blockCurY = 21;
		
		updateConsole(blocksColor); // Update with new values
	}
	
	function doKeyDown(evt){ // Monitor the Key Press Event
	
		// Erase the existing block position/rotation
		drawBlock(currentPiece, blockCurX, blockCurY, boardColor);
		
		switch (evt.keyCode) {
			case 38:  // Up key pressed
				rotationIndex=(rotationIndex+1)%pieces[curPieceIndex].length;			
				currentPiece=pieces[curPieceIndex][rotationIndex];
				break;
			case 40:  // Down key pressed
				if(canMoveDown()){
					blockCurY = blockCurY-1;
				}
				else{ // Reached bottom
					reachedBottom();
				}
				break;
			case 37:  // Left key pressed
				if(canMoveLeft()){
					blockCurX = blockCurX-1;
				}
				break;
			case 39:  // Right key pressed
				if(canMoveRight()){
					blockCurX = blockCurX+1;
				}
				break;
		}
		
		// Draw the block at the new position/rotation
		drawBlock(currentPiece, blockCurX, blockCurY, blocksColor);
				
	}
	
	init();
	window.addEventListener('keydown',doKeyDown,true);
</script>

</body>
</html>
